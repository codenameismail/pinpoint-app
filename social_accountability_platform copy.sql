--
-- T-SQL RedGateSchemaCompare T-SQL Script
-- --------------------------------------------------------------------------------------------
--
--  File:              social_accountability_platform.sql
--  Date:              August 24, 2025
--  Description:       Schema for social accountability platform with robust design
--
-- --------------------------------------------------------------------------------------------
--
-- Part 1: Custom Types (Enums)
-- These create strict, predefined lists for certain column values to ensure data integrity.
--
CREATE TYPE public.user_rank AS ENUM ('newcomer', 'contributor', 'motivator', 'mentor', 'champion');
CREATE TYPE public.goal_status AS ENUM ('active', 'paused', 'completed', 'abandoned');
CREATE TYPE public.post_vibe AS ENUM ('seeking_advice', 'making_progress', 'milestone', 'tough_week');
CREATE TYPE public.lock_type AS ENUM ('none', 'focus', 'feed');
CREATE TYPE public.media_type AS ENUM ('profile_image', 'goal_image', 'update_image');
CREATE TYPE public.notification_preference AS ENUM ('all', 'important', 'none');

--
-- Part 2: Tables
--
-- Profiles Table
-- Stores public user data, linked to the authentication system.
--
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    username text NOT NULL UNIQUE CHECK (username ~ '^[a-zA-Z0-9_]{3,30}$'),
    full_name text NULL,
    bio text NULL CHECK (char_length(bio) <= 500),
    rank public.user_rank NOT NULL DEFAULT 'newcomer',
    reputation_score int NOT NULL DEFAULT 0,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    deleted_at timestamptz NULL
);
-- Essential index for username lookups - keep this
CREATE INDEX idx_profiles_username ON public.profiles (username);

COMMENT ON TABLE public.profiles IS 'Public profile data for each user.';
COMMENT ON COLUMN public.profiles.bio IS 'User biography, limited to 500 characters.';
COMMENT ON COLUMN public.profiles.reputation_score IS 'Accumulated reputation from helpful comments.';
COMMENT ON COLUMN public.profiles.deleted_at IS 'Timestamp for soft deletion of profile.';

-- User Settings Table
-- Stores user preferences for notifications, privacy, and app behavior.
--
CREATE TABLE public.user_settings (
    user_id uuid NOT NULL PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    notification_preference public.notification_preference NOT NULL DEFAULT 'all',
    dark_mode boolean NOT NULL DEFAULT false,
    allow_mentions boolean NOT NULL DEFAULT true,
    language text NOT NULL DEFAULT 'en',
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.user_settings IS 'User configurable settings and preferences.';

-- Goal Categories Table
-- Stores predefined categories for goals.
--
CREATE TABLE public.goal_categories (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL UNIQUE,
    description text NULL,
    icon_name text NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.goal_categories IS 'Predefined categories for organizing goals.';
COMMENT ON COLUMN public.goal_categories.icon_name IS 'Name of icon to display for this category.';

-- Goals Table
-- The user's primary objectives.
--
CREATE TABLE public.goals (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    category_id bigint NOT NULL REFERENCES public.goal_categories(id),
    title text NOT NULL CHECK (char_length(title) BETWEEN 3 AND 120),
    motivation_text text NULL CHECK (char_length(motivation_text) <= 1000),
    target_date date NULL,
    status public.goal_status NOT NULL DEFAULT 'active',
    completed_at timestamptz NULL,
    completion_summary_achievement text NULL,
    completion_summary_learning text NULL,
    is_public boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    deleted_at timestamptz NULL
);
-- Essential index for user goals lookup - keep this
CREATE INDEX idx_goals_user_id ON public.goals (user_id);
-- Essential index for category lookups - keep this
CREATE INDEX idx_goals_category_id ON public.goals (category_id);

COMMENT ON TABLE public.goals IS 'User-defined goals and objectives.';
COMMENT ON COLUMN public.goals.is_public IS 'Whether this goal is visible to other users.';
COMMENT ON COLUMN public.goals.deleted_at IS 'Timestamp for soft deletion of goal.';

-- Goal Updates Table
-- Weekly check-in posts for each goal.
--
CREATE TABLE public.goal_updates (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    goal_id uuid NOT NULL REFERENCES public.goals(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    win_text text NOT NULL CHECK (char_length(win_text) BETWEEN 1 AND 2000),
    challenge_text text NOT NULL CHECK (char_length(challenge_text) BETWEEN 1 AND 2000),
    vibe_tag public.post_vibe NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    deleted_at timestamptz NULL
);
-- Essential index for goal_id lookups - keep this
CREATE INDEX idx_goal_updates_goal_id ON public.goal_updates (goal_id);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_goal_updates_user_id ON public.goal_updates (user_id);

COMMENT ON TABLE public.goal_updates IS 'Weekly progress updates for a goal.';
COMMENT ON COLUMN public.goal_updates.deleted_at IS 'Timestamp for soft deletion of update.';

-- Media Table
-- Stores metadata for all uploaded media files (images, etc.)
--
CREATE TABLE public.media (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    media_type public.media_type NOT NULL,
    related_id uuid NULL, -- Can reference profile_id, goal_id, or update_id
    storage_path text NOT NULL,
    file_name text NOT NULL,
    file_size int NOT NULL,
    mime_type text NOT NULL,
    width int NULL,
    height int NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    deleted_at timestamptz NULL
);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_media_user_id ON public.media (user_id);
-- Essential index for related_id lookups - keep this
CREATE INDEX idx_media_related_id ON public.media (related_id);

COMMENT ON TABLE public.media IS 'Metadata for user-uploaded media files.';
COMMENT ON COLUMN public.media.related_id IS 'ID of the related entity (profile, goal, update).';
COMMENT ON COLUMN public.media.storage_path IS 'Path to file in storage bucket.';

-- Comments Table
-- Feedback and support from other users on goal updates.
--
CREATE TABLE public.comments (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    update_id uuid NOT NULL REFERENCES public.goal_updates(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    comment_text text NOT NULL CHECK (char_length(comment_text) BETWEEN 1 AND 1000),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    deleted_at timestamptz NULL
);
-- Essential index for update_id lookups - keep this
CREATE INDEX idx_comments_update_id ON public.comments (update_id);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_comments_user_id ON public.comments (user_id);

COMMENT ON TABLE public.comments IS 'User comments on goal updates.';
COMMENT ON COLUMN public.comments.deleted_at IS 'Timestamp for soft deletion of comment.';

-- Helpful Marks Table
-- Logs when a comment is marked as helpful, driving the reputation system.
--
CREATE TABLE public.helpful_marks (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    comment_id uuid NOT NULL REFERENCES public.comments(id) ON DELETE CASCADE,
    update_owner_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    commenter_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (comment_id, update_owner_id)
);
-- Essential index for commenter_id lookups - keep this
CREATE INDEX idx_helpful_marks_commenter_id ON public.helpful_marks (commenter_id);
COMMENT ON TABLE public.helpful_marks IS 'Tracks when a comment is marked as helpful.';

-- User Commitments Table
-- Tracks a user's promise to post updates for a specific goal.
--
CREATE TABLE public.user_commitments (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    goal_id uuid NOT NULL REFERENCES public.goals(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    frequency_per_week int NOT NULL CHECK (frequency_per_week IN (1, 2, 3)),
    last_compliant_at timestamptz NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (goal_id, user_id)
);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_user_commitments_user_id ON public.user_commitments (user_id);
COMMENT ON TABLE public.user_commitments IS 'User commitments for posting frequency.';
COMMENT ON COLUMN public.user_commitments.frequency_per_week IS 'Number of updates per week user commits to (1-3).';

-- Accountability States Table
-- Manages the current lock state of a user based on their commitment compliance.
--
CREATE TABLE public.accountability_states (
    user_id uuid NOT NULL PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    current_lock public.lock_type NOT NULL DEFAULT 'none',
    reason text NULL,
    until timestamptz NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.accountability_states IS 'Current accountability lock state for a user.';
COMMENT ON COLUMN public.accountability_states.until IS 'When the lock expires.';

-- Favorites Table
-- Tracks users' favorite goals for easy access
--
CREATE TABLE public.favorites (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    goal_id uuid NOT NULL REFERENCES public.goals(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (user_id, goal_id)
);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_favorites_user_id ON public.favorites (user_id);
COMMENT ON TABLE public.favorites IS 'User-favorited goals for quick access.';

-- Notifications Table
-- Stores in-app notifications for users.
--
CREATE TABLE public.notifications (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type text NOT NULL,
    payload jsonb NOT NULL DEFAULT '{}'::jsonb,
    read_at timestamptz NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_notifications_user_id ON public.notifications (user_id);

COMMENT ON TABLE public.notifications IS 'In-app notifications for user events.';
COMMENT ON COLUMN public.notifications.payload IS 'JSON data specific to notification type.';

-- Push Tokens Table
-- Stores user device tokens for sending push notifications.
--
CREATE TABLE public.push_tokens (
    id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    token text NOT NULL UNIQUE,
    device_name text NULL,
    device_type text NULL,
    last_used_at timestamptz NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);
-- Essential index for user_id lookups - keep this
CREATE INDEX idx_push_tokens_user_id ON public.push_tokens (user_id);
COMMENT ON TABLE public.push_tokens IS 'Stores Expo push tokens for devices.';
COMMENT ON COLUMN public.push_tokens.device_name IS 'User-friendly device name.';
COMMENT ON COLUMN public.push_tokens.device_type IS 'Device platform (iOS, Android).';



--
-- Part 3: Functions and Triggers
--

-- Automatically create a profile when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  -- 1) Insert a matching row in your profiles table
  INSERT INTO public.profiles (id, username, full_name)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username',
    NEW.raw_user_meta_data->>'full_name'
  );
  
  -- 2) Insert a matching row in user_settings with defaults
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id);
  
  RETURN NEW;
END;
$$;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Automatically update the updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create updated_at triggers for all tables with that column
CREATE TRIGGER update_profiles_modtime
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_goals_modtime
    BEFORE UPDATE ON public.goals
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_goal_updates_modtime
    BEFORE UPDATE ON public.goal_updates
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_comments_modtime
    BEFORE UPDATE ON public.comments
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_user_settings_modtime
    BEFORE UPDATE ON public.user_settings
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_media_modtime
    BEFORE UPDATE ON public.media
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_user_commitments_modtime
    BEFORE UPDATE ON public.user_commitments
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_accountability_states_modtime
    BEFORE UPDATE ON public.accountability_states
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_push_tokens_modtime
    BEFORE UPDATE ON public.push_tokens
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

CREATE TRIGGER update_goal_categories_modtime
    BEFORE UPDATE ON public.goal_categories
    FOR EACH ROW EXECUTE FUNCTION public.update_modified_column();

-- Function to update reputation score when a comment is marked helpful
CREATE OR REPLACE FUNCTION public.update_reputation_on_helpful()
RETURNS TRIGGER AS $$
BEGIN
    -- Increase commenter's reputation by 5 points
    UPDATE public.profiles
    SET reputation_score = reputation_score + 5
    WHERE id = NEW.commenter_id;
    
    -- Create a notification for the commenter
    INSERT INTO public.notifications (user_id, type, payload)
    VALUES (
        NEW.commenter_id,
        'comment_marked_helpful',
        jsonb_build_object(
            'comment_id', NEW.comment_id,
            'marker_id', NEW.update_owner_id
        )
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_helpful_mark_created
    AFTER INSERT ON public.helpful_marks
    FOR EACH ROW EXECUTE FUNCTION public.update_reputation_on_helpful();

-- Function to check if a user ranks up based on reputation
CREATE OR REPLACE FUNCTION public.check_rank_upgrade()
RETURNS TRIGGER AS $$
BEGIN
    -- Update rank based on reputation thresholds
    UPDATE public.profiles
    SET rank = CASE 
        WHEN NEW.reputation_score >= 500 THEN 'champion'::public.user_rank
        WHEN NEW.reputation_score >= 250 THEN 'mentor'::public.user_rank
        WHEN NEW.reputation_score >= 100 THEN 'motivator'::public.user_rank
        WHEN NEW.reputation_score >= 25 THEN 'contributor'::public.user_rank
        ELSE 'newcomer'::public.user_rank
    END
    WHERE id = NEW.id AND rank != CASE 
        WHEN NEW.reputation_score >= 500 THEN 'champion'::public.user_rank
        WHEN NEW.reputation_score >= 250 THEN 'mentor'::public.user_rank
        WHEN NEW.reputation_score >= 100 THEN 'motivator'::public.user_rank
        WHEN NEW.reputation_score >= 25 THEN 'contributor'::public.user_rank
        ELSE 'newcomer'::public.user_rank
    END;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_reputation_change
    AFTER UPDATE OF reputation_score ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.check_rank_upgrade();